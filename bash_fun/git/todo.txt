TODO:
    Write a README.md
    Create an env var and function for finding the primary branch of a repo.
        Possibly use a custom git config entry for this.
    Refactor git_commit_diff:
        Create a --diff-args flag. Everything after that is added to the diff command.
        Create a --log-args flag. Everything after that is added to the log command.
        Create a --commits|--hashes flag. Everything after that is a commit hash.
        Keep the --commit|--hash flag but make them the same as their plural counterparts.
        Anything not after --diff-args or --log-args is a commit hash.
        Remove the -- special handling.
        New usage: git_commit_diff [<commit hash> ...] [--select] [--diff-args <git diff arg> ...]] [--log-args <git log arg> ...]] [(--commit|--commits|--hash|--hashes) <commit hash> ...]
        Add a preview window to the --select that shows a compact summary of that commit.
        Probably want to have a top/bottom layout with preview/summary on top and commits on bottom.
        Possibly have a hotkey that launches git_diff_explorer on the selected commit.
    Git diff explorer
        Usage: git_diff_explorer <git diff args>
        Basically, it should do a `git diff --compact-summary "$@"` and then `git diff "$@" <file>`.
        Use fzf with a preview window.
            I tried a side-by side version, but it was too limiting. fzf truncates things left-to right, but allows scrolling.
            So I decied a bottom/top would be better, with the compact summary on bottom and the file diff on top.
        Lines that are selected will result in the diff being printed.
        Here's what I've got so far:
            git --no-pager diff --color=always --compact-summary "$@" | tac | fzf --ansi --header-lines 1 --cycle -m --preview='git_diff_explorer_preview '"$preview_args"' -- "{}"' --preview-window='top,75%,border-bottom,~4'
            I need to create the git_diff_explorer_preview program that will take in the compact summary line, extract the filename and output the diff.
                In the preview command, $@ won't get expanded correctly. It'll get expaned too early which will cause problems if file paths have spaces.
                To get around that, I'll need to make a special string by escaping any ' in any of the $@, then wrap each in ' and join them with a space between.
                    preview_args="$( for arg in "$@"; do printf '%s ' "'$( sed 's/'"'"'/\\'"'"'/g' <<< "$arg" )'"; done )"
                There'll be an extra space at the end, but whatever.
            I tried a side-by side version, but fzf truncates long lines (no left/right scroll), so it didn't show enough, and wrapping on that skinny of a space was annoying.
            So I decided a top/bottom version was better. I put the summary on bottom since that's where you usually look in fzf.
            I only have a border between the sections because a full border around the diff area just took up extra space and didn't help anything.
            I tried with cycle in there, but since you can only scroll it with mouse stuff (not up/down arrows), that was annoying (specially when trying to see the bottom).
            The ~4 keeps the top 4 lines of the diff, which are the diff header lines with command, index and file info.
        Have a --commit <hash> option that does the diff of a single commit, similar to this:
            git --no-pager diff "<hash>~" "<hash>" <other args>
            Basically, replace the "--commit <arg>" with "<arg>~" "<arg>" in the provided arguments.
        To parse a --compact-summary line:
            file_entry="$( sed -E 's/^[[:space:]]+//; s/([[:space:]]+\([^)]+\))?[[:space:]]+\|[[:space:]]+[[:digit:]]+([[:space:]]+[+-]+)?[[:space:]]*$//;' <<< "$line" )"
            Then, to handle moved files:
                file1="$( sed -E 's/{(.*) => (.*)}/\1/g; s/(.*) => (.*)/\1/g' <<< "$file_entry" )"
                file2="$( sed -E 's/{(.*) => (.*)}/\2/g; s/(.*) => (.*)/\2/g' <<< "$file_entry" )"
        To get the specific file diff:
            git --no-pager diff --color=always "$@" -- <file1> <file2>
            This works just fine if file1 and file2 are the same thing (e.g. the file wasn't moved).
        Problem:
            The compact summary outputs paths to files relative to the repo root, but git diff expects paths relative to current location.
            So if you're somewhere other than the repo root, the paths can't be passed directly to git diff.
            I can't seem to find a way to go from the full git path (from the repo root) to the relative path though.
            The command `git ls-files --full-path <file>` will go from a relative path to full path, but I don't see an opposite.
            Also, if the --relative flag is provided, the compact summary is limited to the current directory (or the dir provided) and all paths are relative.
            Possible solution:
                First, check the config for a `diff.relative` entry. If it's there, set it's value as the root dir
                When parsing args, Look for --relative[=<path>] (and --no-relative).
                    If --relative=<path> is provided, identify <path> as the root dir.
                    If --relative is provided (without a path), idenitfy '.' as the root dir.
                    If --no-relative is provided, unset the root dir.
                Then, if there's no root dir identified, set it to the output of `git rev-parse --show-toplevel`.
                Then, use `realpath --relative-to='.' '<root_dir>/<filename>' to get the relative path to the file.

