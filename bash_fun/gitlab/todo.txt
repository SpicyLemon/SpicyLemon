TODO:
* standardize the naming of all the functions.
* rename GITLAB_BASE_DIR variable to GITLAB_REPO_DIR
* Create a helper for setting up tab complete, and move that responsibility into each file.
* Make the main gitlab function more dynamic by only showing options that are usable.
* Add support for groups similar to the way projects work.
* Look into using groups for deep-scanning for mrs.
* Create method for wrapping curl calls that will retrieve both the response and header.
* Use the header information to get all results of a search.
* Create a generic search function.
* create a way to look up (and open) pipelines for a repo/branch (similar to gljobs).

Thoughts:
* All functions in core should start with __gl_
* Think of different name for __ensure_gitlab_token.
    The "ensure" part in that function means that if the token isn't available, we should stop.
    But the "ensure" part in the other functions means fix the problem if there is one.
* For the functions that make the urls, replace the __get_gitlab part with just __gl_api_
* Move the glopen url creators down with the other url creators and have them start with __gl_web_
* The gitlab interaction functions should be the only ones with "get" in them.
* Maybe split out __add_approved_status_to_mrs_i_created and __add_discussion_info_to_mrs into lookup and data joining pieces.
* Data manipulation methods with "get" in them can be changed to use "lookup"


Extra notes and info on the search endpoint:

gitlab search:

https://docs.gitlab.com/ee/api/search.html

Scopes          global  groups  projects
projects         yes     yes     no
issues           yes     yes     yes
merge_requests   yes     yes     yes
milestones       yes     yes     yes
notes            no      no      yes
snippet_titles   yes     no      no
snippet_blobs    yes     no      no
wiki_blobs       yes     yes     yes
commits          yes     yes     yes
blogs            yes     yes     yes
users            yes     yes     yes

Global endpoint: https://gitlab.com/api/v4/
Groups endpoint: https://gitlab.com/api/v4/groups/:id/search
Projects endpoints: https://gitlab.com/api/v4/projects/:id/search

All three have two required parameters: scope search
Projects has an optional parameter: ref

Endpoint for our group (sofi): https://gitlab.com/api/v4/groups/3924854/search

per_page is ignored and the endpoint returns 20 results at a time.
page can be used to get specific pages, but probably better to use the links out of the header.

For code search, use scope=blobs

Example curl command with search:
curl -s --header "PRIVATE-TOKEN: $GITLAB_PRIVATE_TOKEN" 'https://gitlab.com/api/v4/groups/3924854/search?scope=blobs&search=getOfferById'


Response header:

< HTTP/2 200
< date: Tue, 14 Apr 2020 21:04:56 GMT
< content-type: application/json
< set-cookie: __cfduid=d4b1337306e9d8ceef7ad3ebde54bc3d91586898294; expires=Thu, 14-May-20 21:04:54 GMT; path=/; domain=.gitlab.com; HttpOnly; SameSite=Lax; Secure
< vary: Accept-Encoding
< cache-control: max-age=0, private, must-revalidate
< etag: W/"1b855df995bfb361102565116cf79b8a"
< link: <https://gitlab.com/api/v4/groups/3924854/search?id=3924854&page=2&per_page=20&scope=blobs&search=getOfferById>; rel="next", <https://gitlab.com/api/v4/groups/3924854/search?id=3924854&page=1&per_page=20&scope=blobs&search=getOfferById>; rel="first", <https://gitlab.com/api/v4/groups/3924854/search?id=3924854&page=6&per_page=20&scope=blobs&search=getOfferById>; rel="last"
< vary: Origin
< x-content-type-options: nosniff
< x-frame-options: SAMEORIGIN
< x-next-page: 2
< x-page: 1
< x-per-page: 20
< x-prev-page:
< x-request-id: sTMcY2cbq3a
< x-runtime: 1.994840
< x-total: 114
< x-total-pages: 6
< strict-transport-security: max-age=31536000
< referrer-policy: strict-origin-when-cross-origin
< ratelimit-limit: 600
< ratelimit-observed: 21
< ratelimit-remaining: 579
< ratelimit-reset: 1586898356
< ratelimit-resettime: Tue, 14 Apr 2020 21:05:56 GMT
< gitlab-lb: fe-06-lb-gprd
< gitlab-sv: localhost
< cf-cache-status: DYNAMIC
< expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"
< server: cloudflare
< cf-ray: 584061c4b9c5bc9c-SEA
<




Here's some stuff I did that might come in handy later:
Got all the results:
    RESULTS='[]'; for p in $( seq 1 6 ); do RESULTS="$( jq -c 'add' <<< "$( echo -E -n "[$RESULTS,$( curl -s --header "PRIVATE-TOKEN: $GITLAB_PRIVATE_TOKEN" "https://gitlab.com/api/v4/groups/3924854/search?scope=blobs&search=getOfferById&per_page=20&page=$p" )]" )" )"; done
That only really worked because I knew ahead of time that there were 6 pages.
Added the project_name to each entry:
    RESULTS="$( jq --sort-keys --argjson projects "$( echo -E "{$({ for project_id in $( jq -r '[ .[] | .project_id ] | unique | .[] ' <<< "$RESULTS" ); do echo "$( __get_project_name $project_id )~$project_id"; done } | sort | awk '{ split($0,a,"~"); if (NR!=1) printf ","; printf "\"" a[2] "\":\"" a[1] "\""; }')}" )" '[ .[] | .project_name = $projects[.project_id|tostring] ]' <<< "$RESULTS" )"
Make sure to __ensure_gitlab_projects first, though.
List the project ids and names that had results:
    jq -r ' [ .[] | (.project_id|tostring) + "  " + .project_name ] | unique | sort_by(.[10:]) | .[] ' <<< "$RESULTS"
Get just the results for a single project:
    jq --sort-keys ' [ .[] | select(.project_id == 11418074) ] | sort_by(.basename) ' <<< "$RESULTS"
Get all the project entries for projects in the results:
    jq --sort-keys --argjson project_ids "$( jq -c ' [ .[] | .project_id ] | unique ' <<< "$RESULTS" )" ' [ .[] | select( .id | IN($project_ids[]) ) | { (.id|tostring): . } ] | add ' <<< "$GITLAB_PROJECTS"
That results in an object where the ids are the keys (as strings), and the values are the project entries.
Group the results by project id and put them into objects so that more info can be added:
    jq ' group_by(.project_id) | [ .[] | { (.[0].project_id|tostring): { "results": . } } ] | add ' <<< "$RESULTS"
That results in: { '<project_id>': { "results": [...] }, ... }
Combine two objects like you'd have in the above results and the grouped project results:
    jq -c --sort-keys --argjson obj_a '{"a":{"v1":1,"v2":[2,4,6]}}' ' . * $obj_a ' <<< '{"a":{"v3":1,"v4":[1,3,5]}}'
That results in: {"a":{"v1":1,"v2":[2,4,6],"v3":1,"v4":[1,3,5]}}
Create a nice final results structure:
    jq --sort-keys --argjson projects "$( jq -c --argjson project_ids "$( jq -c ' [ .[] | .project_id ] | unique ' <<< "$RESULTS" )" ' [ .[] | select( .id | IN($project_ids[]) ) | { (.id|tostring): . } ] | add ' <<< "$GITLAB_PROJECTS" )" ' group_by(.project_id) | [ .[] | { (.[0].project_id|tostring): { "results": . } } ] | add | . * $projects | [ .[] ] ' <<< "$RESULTS"
That will return a list of project entries with an added "results" key containing the search results.
The final '| [ .[] ] ' turns the result from an object (with project ids for keys) into a list of what used to be the object values.

Sample blob result entry:
    {
        "basename": "src/test/java/com/sofi/products/api/PLPrimeProductTest",
        "data": "\n        assertEquals(packet, client.getUwPacket(packet.getId()));\n        assertEquals(offer, client.getOfferById(offer.getId()));\n    }\n\n",
        "filename": "src/test/java/com/sofi/products/api/PLPrimeProductTest.java",
        "id": null,
        "path": "src/test/java/com/sofi/products/api/PLPrimeProductTest.java",
        "project_id": 11418074,
        "ref": "f27e763765c89655a71f8debc1a19834cff5fadb",
        "startline": 642
    }
Note that the "filename" field is deprecated. Use "path" instead.

TODO:
    Need to look into jq reduce functions to get a count of results per project.

