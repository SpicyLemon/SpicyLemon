TODO:
    Replace uses of echo with printf.
    Replace "echo ... |" and "printf ... |" stuff with herestrings.
        To find most spots: grep -E "(echo|printf) .*\|" *
        Note that a herestring will add a newline to the end which can sometimes cause problems.
    Additional output helpers for stripping more than just colors.
        Need to research escape codes more to know exactly what should be stripped.
    Add recursive functionality to list.sh.
        Will need to keep track of directories seen (using pwd -P) to prevent infinite loops.
    Create a thing that takes in a URL and gets info about it including where it might redirect to.
        Give it recursive ability so that it can keep on following the trail, getting info as it goes.
    Create a simple thing that I can pipe things into that makes sure it ends in a newline.
        That is, if the very last character is a newline, do nothing, otherwise print a newline.
        Will probably want to do some fancy tee stuff to both output the stuff and also check the last character.
        Stuff that might be handy:
            $ printf 'this does not end in newline' > no-newline.txt
            $ printf 'this does have a newline at the end\n' > with-newline.txt
            $ [[ "$( tail -c 1 no-newline.txt )" == "$( printf '\n' )" ]]
            exit code is 1
            $ [[ "$( tail -c 1 with-newline.txt )" == "$( printf '\n' )" ]]
            exit code is 0
            $ cat no-newline.txt | [[ "$( tail -c 1 )" == "$( printf '\n' )" ]]
            exit code is 1
            $ cat with-newline.txt | [[ "$( tail -c 1 )" == "$( printf '\n' )" ]]
            exit code is 0
        There might be something easier than "$( printf '\n' )", but just '\n' and "\n" didn't work as expected.
    Do some sub-categorization of this stuff.
        The color stuff could be in one.
            Stuff like echo_color.sh, palette_generators.sh, show_palette.sh, and probably hrr.sh too.
            I'm torn on strip_colors.sh though since there's also tee_strip_colors.sh and tee_strip_colors_pbcopy.sh, which are kind of something else.
        The sdkman_fzf.sh wrapper might be better placed one directory up.
        The math stuff could be grouped up: add.sh, multiply.sh, min.sh, max.sh
        Maybe some string manipulation stuff too, e.g. string_repeate.sh and change_word.sh.
        The hrr.sh file should probably be split out into individual files too. I don't know though, they're pretty simple, but who knows.
            That'd let some of the more palette oriented functions go into the color stuff too.
    Maybe deprecate some of the following:
        chrome_cors.sh
            I've no idea if this actually still even works.
            Last time I tried, I think there were complications.
        fp.sh
            I've had some issues with this one.
            There's probably some already-made shell built-in stuff that would be better suited to solve this.
            So maybe it's not due for deprecation, maybe it just needs an overhaul.
        get_shell_type.sh
            This was originally intended so that things could be handled differently in different shells.
            Since then, though, I've figured out better ways of handling it.
            Usually it's just testing for the exact functionality I'm about to use.
                if command -v "whatever" > /dev/null 2>&1; then ...
        i_can.sh, strip_colors.sh, strip_final_newline.sh, tee_pbcopy.sh, tee_strip_colors.sh, tee_strip_colors_pbcopy.sh
            Can probably just as easily be aliases.
    Add more generic preprocessing to multidiff.
        I picture it kind of like xargs where you supply a command to run on each file.
        The output of each is put into a temp file and the diffs are done on those.
        I'd definitely want a way to indicate that the filename should be placed in a certain spot in the command rather than at the end though.
            It's probably a good idea to just add a -I replstr flag to the multidiff command that really only gets used if a --pre is given.
            And if no -I was given, the filename would just go at the end of what was given.
        I'll probably need a way to disambiguate between the pre-defined "jq" and "json_info" preprocessors though.
            I'm not sure if just checking for specific ones is okay or not.
            How often will the desired pre-processing command just be a single word?, e.g. stat
                I'm guessing not much since it took me a while to find a command that's just <cmd> <filename> that might be usable.
                I think that in almost all cases, it's going to be fine as long as the pre-defined ones are single words (or underscored).
            Or.... maybe turn change --pre-process jq and --pre-process json_info into just --jq and --json-info flags
            How fancy do I want to get about being able to apply multiple pre-processing commands?
                e.g. --json-info --pre-process 'grep "\.some.subfield.'
    Add a newline to the output of add.sh and multiply.sh
    Create a palette_walk_generate and palette_walk_random
        Usage: palette_walk_generate <start> <step1> [<step2> ...]
        Each <step> would have the format "<dx>,<dy>,<dz>".
            It's either that or have each step actually be 3 arguments, but that seems like it'd get hard to keep track of.
        Any number of steps can be given.
        Usage: palette_walk_random [<start>] [<length>]
        Same as the other palette_vector_random function, '' can be provided to keep an arg random.
